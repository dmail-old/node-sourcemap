var SourceMapConsumer = require('source-map').SourceMapConsumer;
var path = require('path');
var fs = require('fs');
var url = require('url');

var TraceError = require('./trace-error');

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

function retrieveFile(path){
	// Trim the path to make sure there is no extra whitespace.
	path = path.trim();
	if( path in fileContentsCache ){
		return fileContentsCache[path];
	}

	var contents;

	if( path in System.sources ){
		contents = System.sources[path];
	}
	else{
		try{
			contents = fs.readFileSync(path, 'utf8');
		}
		catch (e) {
			contents = null;
		}
	}

	return fileContentsCache[path] = contents;
}

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://")
function supportRelativeURL(file, base){
	if( !file ) return base;
	return url.resolve(file, base);
}

function retrieveSourceMapURL(source){
	var fileData;

	// Get the URL of the source map
	fileData = retrieveFile(source);
	//        //# sourceMappingURL=foo.js.map                       /*# sourceMappingURL=foo.js.map */
	var re = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/)[ \t]*$)/mg;
	// Keep executing the search to find the *last* sourceMappingURL to avoid
	// picking up sourceMappingURLs from comments, strings, etc.
	var lastMatch, match;
	while( match = re.exec(fileData) ){
		lastMatch = match;
	}
	if( !lastMatch ) return null;
	return lastMatch[1];
}

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
function retrieveSourceMap(source){
	var sourceMappingURL = retrieveSourceMapURL(source);
	if( !sourceMappingURL ) return null;

	// Read the contents of the source map
	var sourceMapData;
	if( reSourceMap.test(sourceMappingURL) ){
		// Support source map URL as a data url
		var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
		sourceMapData = new Buffer(rawData, "base64").toString();
		sourceMappingURL = null;
	}
	else {
		// Support source map URLs relative to the source URL
		sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
		sourceMapData = retrieveFile(sourceMappingURL);
	}

	if( !sourceMapData ){
		return null;
	}

	return {
		url: sourceMappingURL,
		map: sourceMapData
	};
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin){
	// Most eval() calls are in this format
	var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
	if( match ){
		var position = mapSourcePosition({
			source: match[2],
			line: match[3],
			column: match[4] - 1
		});
		return 'eval at ' + match[1] + ' (' + position.source + ':' + position.line + ':' + (position.column + 1) + ')';
	}

	// Parse nested eval() calls using recursion
	match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
	if( match ){
		return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
	}

	// Make sure we still return useful information if we didn't find anything
	return origin;
}

function mapSourcePosition(position){
	position.source = position.source.replace('!transpiled', '');

	var sourceMap = sourceMapCache[position.source];
	if( !sourceMap ){
		// Call the (overrideable) retrieveSourceMap function to get the source map.
		var urlAndMap = retrieveSourceMap(position.source);

		if( urlAndMap ){
			sourceMap = sourceMapCache[position.source] = {
				url: urlAndMap.url,
				map: new SourceMapConsumer(urlAndMap.map)
			};

			// Load all sources stored inline with the source map into the file cache
			// to pretend like they are already loaded. They may not exist on disk.
			if( sourceMap.map.sourcesContent ){
				sourceMap.map.sources.forEach(function(source, i) {
					var contents = sourceMap.map.sourcesContent[i];
					if( contents ){
						var url = supportRelativeURL(sourceMap.url, source);
						fileContentsCache[url] = contents;
					}
				});
			}
		}
		else{
			sourceMap = sourceMapCache[position.source] = {
				url: null,
				map: null
			};
		}
	}

	// Resolve the source URL relative to the URL of the source map
	if( sourceMap && sourceMap.map ){
		var originalPosition = sourceMap.map.originalPositionFor(position);

		// Only return the original position if a matching line was found. If no
		// matching line is found then we return position instead, which will cause
		// the stack trace to print the path and line for the compiled file. It is
		// better to give a precise location in the compiled file than a vague
		// location in the original file.
		if( originalPosition.source !== null ){
			originalPosition.source = supportRelativeURL(sourceMap.url || position.source, originalPosition.source);
			return originalPosition;
		}
	}

	return position;
}

function wrapCallSite(callSite){
	var source = callSite.getFileName() || callSite.getScriptNameOrSourceURL();

	if( source ){
		var line = callSite.getLineNumber();
		var column = callSite.getColumnNumber() - 1;

		// Fix position in Node where some (internal) code is prepended.
		// See https://github.com/evanw/node-source-map-support/issues/36
		if( line === 1 && typeof process !== 'undefined' && !callSite.isEval() ) {
			column-= 62;
		}

		var position = mapSourcePosition({
			source: source,
			line: line,
			column: column
		});

		callSite.source = position.source;
		callSite.line = position.line;
		callSite.column = position.column + 1;
		return;
	}

	// Code called using eval() needs special handling
	var origin = callSite.isEval() && callSite.getEvalOrigin();
	if( origin ){
		origin = mapEvalOrigin(origin);
		callSite.evalOrigin = origin;
		return;
	}
}

// Generate position and snippet of original source with pointer
function getErrorSource(traceError){
	if( traceError.callSites.length === 0 ) return null;

	var firstCall = traceError.callSites[0];
	var source = firstCall.getFileName();
	var line = firstCall.getLineNumber();
	var column = firstCall.getColumnNumber();
	var contents;

	if( source && line && column ){
		// Support the inline sourceContents inside the source map
		contents = fileContentsCache[source];

		// Support files on disk
		if( !contents && fs.existsSync(source) ){
			contents = fs.readFileSync(source, 'utf8');
		}

		// Format the line from the original source code like node does
		if( contents ){
			var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
			if( code ){
				return source + ':' + line + '\n' + code + '\n' + new Array(column).join(' ') + '^';
			}
		}
	}

	return null;
}

function replaceErrorStackUsingSourceMap(error){
	var trace = new TraceError(error);

	trace.callSites.forEach(wrapCallSite);
	trace.source = getErrorSource(trace);

	return trace;
}

module.exports = replaceErrorStackUsingSourceMap;